### 要約

この規格は, ERC-20との後方互換性を保ちつつ, トークンコントラクトと対話するための新しい方法を定義しています.

特に新しい概念が２つあります.

- 他のアドレス(コントラクトまたはレギュラーアカウント)に代わってトークンを送信するオペレータ
- トークン所有者が自分のトークンをよりコントロールできるようにする送受信フック

### イベントについて

イベントがERC20と777で区別されていることを記述する

### ERC777 需要な点

本規格は，ERC-20との後方互換性を保ちつつ，ERC-20の欠点を解決し，EIP-223の問題点や脆弱性を回避することを主な意図としている。

以下、規格の主要な点に関する決定の根拠を示す。

- Lifecycle

ERC-777では、単にトークンを送るだけでなく、トークンのライフサイクル全体を定義しており、造幣プロセスから始まり、送信プロセス、燃焼プロセスで終了します。

ライフサイクルが明確に定義されていることは、特に希少性から価値が生まれる場合には、一貫性と正確性の点で重要です。一方、いくつかの ERC-20 トークンを見てみると、トークンの生成と破棄のプロセスが規格で明確に定義されていないため、totalSupply が返す値と実際の流通量との間に不一致が見受けられます。

- Data

ミント、センド、バーン処理はすべて、あらゆる動き（ミント、センド、バーン）に渡されるデータおよびオペレータデータフィールドを利用することができます。これらのフィールドは、単純なユースケースでは空かもしれませんが、送信者または銀行自体によって銀行振込に添付された情報のように、トークンの移動に関連する貴重な情報を含むかもしれません。

データフィールドの使用は、EIP-223 などの他の標準提案にも同様に存在し、この標準を検討したコミュニティの複数のメンバーから要求されました。

- Hooks

ほとんどの場合、ERC-20では、トークンをロックせずに安全にコントラクトに転送するために2つのコールが必要です。送信側からのApprove関数を使ったコールと、受信側からのtransferFromを使ったコールです。さらに、これは当事者間の余分なコミュニケーションを必要とし、明確に定義されていません。最後に、保有者はtransferとapprove/transferFromを混同してしまう可能性があります。前者を使用してトークンをコントラクトに転送すると、トークンがロックされる可能性が高くなります。
ロックとは？

フックは送信プロセスの合理化を可能にし、あらゆる受信者にトークンを送信する単一の方法を提供します。tokensReceived フックのおかげで、コントラクトは受信時に反応し、トークンのロックを防ぐことができる。 <- これがtokensReceivedがコントラクトには実装されてなければいけない理由

tokensReceivedフックは、保有者がいくつかのトークンの受信を拒否することも可能です。これは、例えばdataやoperatorDataフィールドにあるいくつかのパラメータに基づいて、受信したトークンを受け入れるか拒否するかを保持者に大きく制御させることができます。

同じ意図で、コミュニティからの提案に基づいて、tokensToSend フックが追加され、送信するトークンの移動を制御したり防いだりできるようになりました。

IERC1820を使用することは, 既存の何もフックを登録していない・実装していないコントラクトでもERC777を使用できるという点で互換性を保つ

- Operator

本標準規格では、トークンを移動させるあらゆるアドレスをオペレータの概念として定義しています。直感的には、すべてのアドレスがそれ自身のトークンを移動させますが、ホルダーとオペレータの概念を分離することで、より柔軟性を持たせることができます。これは主に、ホルダーが他のアドレスをオペレーターにできる仕組みを定義していることに起因しています。さらに、承認されたアドレスの役割が明確に定義されていないERC-20の承認コールとは異なり、ERC-777ではオペレータの意図やオペレータとのやり取りが詳細に記述されており、オペレータを承認する義務や、オペレータを取り消すホルダー側の取り消し不能な権利も含まれています。

デフォルトのオペレータは、事前承認されたオペレータに対するコミュニティの要求に基づいて追加されました。つまり、デフォルトですべての保有者に承認されるオペレータです。セキュリティ上の理由から、デフォルトのオペレータのリストは、トークン契約作成時に定義され、変更することはできません。どの保有者も、デフォルトのオペレータを取り消す権利を持っています。デフォルトのオペレータの明らかな利点の1つは、トークンの移動をエーテルレスで行えることです。デフォルトのオペレータは、トークン提供者がモジュール方式で機能を提供できるようにし、保有者がオペレータを通じて提供される機能を使用する際の複雑さを軽減するなど、他のユーザビリティ上の利点もあります。

オペレータという概念を足して, オペレータが呼び出す場合は関数が分かれているのが重要な気がする

### 後方互換性について

このEIPはtransferとtransferFromを使用せず、sendとoperatorSendを使用し、どのトークン規格が使用されているかを解読する際の混乱や間違いを避けるようにしています。

この規格では、ERC-20の関数transfer, transferFrom, approve, allowanceを並行して実装することで、ERC-20と完全互換のトークンとすることができます。

コントラクトに ERC20 機能を有効または無効にするスイッチがある場合、スイッチが起動するたびに、トークンは ERC1820 を介して自身のアドレスの ERC20Token インタフェースを適宜登録または登録解除しなければなりません (MUST)。登録を解除するには、トークン契約アドレスをアドレスとして、ERC20Token の keccak256 ハッシュをインターフェースハッシュとして、0x0 を実装者として setInterfaceImplementer を呼び出すことを意味します。(詳細は「ERC-1820のアドレスにインタフェースを設定する」を参照してください)。

したがって、トークンの移動に対して、ERC-20 Transfer と ERC-777 Sent, Minted または Burned (移動のタイプによる)の 2 つのイベントを発行してもよい。サードパーティの開発者は、この2つのイベントを別々の動きと見なさないように注意しなければならない（MUST）。原則として、アプリケーションがトークンを ERC20 トークンと見なす場合、Transfer イベントのみを考慮しなけれ ばなりません。アプリケーションがトークンを ERC777 トークンと見なす場合、Sent、Minted、Burned イベントのみを考慮しなけれ ばなりません(MUST)。